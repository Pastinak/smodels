"""
.. module:: theory.branch
   :synopsis: Module holding the branch class, its methods and related functions.
        
.. moduleauthor:: Andre Lessa <lessa.a.p@gmail.com>
        
"""

from smodels.theory.particle import simParticles
from smodels.tools.physicsUnits import fb
from smodels.theory.vertex import createVertexFromStr
from smodels.theory.auxiliaryFunctions import stringToList
import logging
from smodels.theory.exceptions import SModelSTheoryError as SModelSError

logger = logging.getLogger(__name__)


class Branch(object):
    """
    An instance of this class represents a branch and it holds a list of vertices (Vertex objects).    
    
    
    :ivar vertexList: list of vertices
    :ivar maxWeight: weight of the branch (XSection object)
    """
    
    def __init__(self, vertices = []):
        """
        Initializes the branch. 
        
        :parameter vertices: list of vertices
        """
        self.vertices = vertices
        self.maxWeight = None


    def __str__(self):
        """
        Create the branch bracket notation string, e.g. [[e+],[jet]].
        
        :returns: string representation of the branch (in bracket notation)    
        """
        
        
        st = str([str(v) for v in self.vertices])
        st = st.replace("'", "").replace(" ", "")
        return st
    
    def __len__(self):
        """
        Defines the branch length (equal to its number of vertices)
        :return: number of vertices in the branch
        """
        
        return len(self.vertices)

    def __cmp__(self,other):
        """
        Compares the branch with other.        
        The comparison is made based on the number of vertices, then on the size of each vertex
        (number of particles in the vertex, then particle names and masses, see vertex.__cmp__)
        OBS: The particles inside each vertex MUST BE sorted (see vertex.sortParticles())         
        :param other:  branch to be compared (Branch object)
        :return: -1 if self < other, 0 if self == other, +1, if self > other.
        """        
        
        if len(self) != len(other):
            comp = len(self) >  len(other)
            if comp: return 1
            else: return -1
        elif self.vertices != other.vertices:
            comp = self.vertices > other.vertices
            if comp: return 1
            else: return -1
        else:
            return 0  #Branches are equal

#     
#     def particlesMatch(self, other):
#         """
#         Compare two Branches for matching particles, 
#         allow for inclusive particle labels (such as the ones defined in particles.py)
#         
#         :parameter other: branch to be compared (Branch object)
#         :returns: True if branches are equal (particles and masses match); False otherwise.              
#         """
#         
#         if type (other) != type(self):
#             return False
# 
#         if len(self) != len(other):
#             return False
# 
#         for iv,vertex in enumerate(self.vertices):
#             if len(vertex) != other.vertices[iv]:
#                 return False
#             if not vertex.particlesMatch(other.vertices[iv]):
#                 return False
#         return True
   

    def copy(self):
        """
        Generate an independent copy of self.        
        Faster than deepcopy.
        
        :returns: Branch object
        """
        newbranch = Branch(vertices = [v.copy() for v in self.vertices])
        if not self.maxWeight is None:
            newbranch.maxWeight = self.maxWeight.copy()
        return newbranch


    def _addVertex(self, newVertex):
        """
        Generate a new branch adding the new vertex to the original branch.
        The PID of incoming particle in the new Vertex must match one of the PIDs of outgoing
        particles in the last vertex of the original branch.
        
        :parameter newVertex: Vertex object. Contains both incoming and outgoing particles.  
        :return: extended branch (Branch object). False if there was an error.
        """
        
        if not newVertex.inParticle._pid in [p._pid for p in self.vertices[-1].outParticles]:
            logger.error("New vertex incoming particle does not match"
                           + " any of the last vertex outgoing particles")
            raise SModelSError
        
        newBranch = self.copy()
        newV = newVertex.copy()
        newBranch.vertices.append(newV)
        if not self.maxWeight is None and hasattr(newVertex,'br'):
            newBranch.maxWeight = self.maxWeight*newVertex.br
                

        return newBranch

    def decay(self, vertexDecayDict):
        """
        Generate a list of all new branches generated by the 1-step cascade
        decay of the current branch daughter (outgoing particles in its last vertex).
        OBS: There must be a single (or none) unstable particle in the last vertex. 
        
        :parameter vertexDecayDict: dictionary with the decay vertices 
                                 for all odd particles. 
                                 Keys are PIDs and values are a list of vertices.

        :returns: list of extended branches (Branch objects). Empty list if daughter is stable.
        """

        nUnstable = 0
        newVertices = None
        for p in self.vertices[-1].outParticles:
            if p._pid in vertexDecayDict:
                nUnstable += 1
                newVertices = vertexDecayDict[p._pid]

        if nUnstable > 1:
            logger.error("Can not decay vertex with multiple unstable outgoing particles")
            return False
        elif nUnstable == 0:
            return []
        
        newBranches = [self._addVertex(newVertex) for newVertex in newVertices]
        return newBranches


def createBranchFromStr(branchStr):
    """
    Creates a branch from a string in bracket notation (e.g. [[e+],[jet]])
    Odd-particles are created as empty Particle objects and Even-particles only have 
    the corresponding name.
    :branchStr: string (e.g. [[e+],[jet]])
    :return: Branch object
    """
    
    vertices = []
    for vertex in stringToList(branchStr):
        vertices.append(createVertexFromStr(str(vertex))) 
    
    return Branch(vertices=vertices)

def decayBranches(branchList, vertexDecayDict, sigcut=0. *fb):
    """
    Decay all branches from branchList until all unstable states have decayed.
    
    :parameter branchList: list of Branch() objects containing the first vertex (produced mother and its decay)
    :parameter vertexDecayDict: dictionary with the decay vertices 
                                 for all odd particles. Keys are PIDs and values are a list of vertices.
    :parameter sigcut: minimum sigma*BR to be generated, by default sigcut = 0.
                   (all branches are kept)
    :returns: list of branches (Branch objects)    
    """

    finalBranchList = []
    while branchList:
        # Store branches after adding one step cascade decay
        newBranchList = []
        for inbranch in branchList:
            if sigcut.asNumber() > 0. and inbranch.maxWeight < sigcut:
                # Remove the branches above sigcut and with length > topmax
                continue
            # Add all possible decays of the last vertex to the original branch
            newBranches = inbranch.decay(vertexDecayDict)
            if newBranches:
                # New branches were generated, add them for next iteration
                newBranchList.extend(newBranches)
            else:
                # All particles have already decayed, store final branch
                finalBranchList.append(inbranch)
        # Use new branches (if any) for next iteration step
        branchList = newBranchList
        
    #Sort list by initial branch PID:
    finalBranchList = sorted(finalBranchList, key=lambda branch: branch.vertices[0].inParticle._pid)
    return finalBranchList
